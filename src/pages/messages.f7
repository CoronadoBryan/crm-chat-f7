<template>
  <div class="page">
    <!-- Navbar -->
    <div class="navbar">
      <div class="navbar-bg"></div>

      <div class="navbar-inner sliding">
        <div class="left">
          <a
            href="#"
            class="link"
            @click="${() => $f7.views.main.router.navigate('/')}"
          >
            <i class="icon icon-back"></i>
            <span class="if-not-md">Volver</span>
          </a>
        </div>
        <div class="title">${telefono}</div>
        <div class="right">
          <button
            class="button button-fill color-red"
            @click="${handleFinalizarConversacion}"
            id="btn-finalizar"
            style="display: none"
          >
            Finalizar ConversaciÃ³n
          </button>
          <a class="link icon-only" @click="${handleHistorialFinalizada}">
            <i class="icon f7-icons">history</i>
            <i class="icon f7-icons">clock_fill</i>
          </a>
          <a href="#" class="link icon-only panel-open" data-panel="right">
            <i class="icon f7-icons if-not-md">menu</i>
            <i class="icon material-icons if-md">menu</i>
          </a>
        </div>
      </div>
    </div>

    <!-- Messagebar -->
    <div class="toolbar messagebar" id="messagebar-container">
      <div class="toolbar-inner">
        <div class="messagebar-area">
          <textarea
            id="message-input"
            class="resizable"
            placeholder="Escribe un mensaje..."
          ></textarea>
        </div>
        <a class="link icon-only" @click="${handleSendClick}">
          <i class="icon f7-icons">arrow_up_circle_fill</i>
        </a>
      </div>
    </div>

    <!-- Mensajes -->
    <div class="page-content messages-content" id="messages-content">
      <!-- Mensaje de conversaciÃ³n finalizada -->
      <div id="mensaje-finalizada" class="mensaje-finalizada-container">
        <p class="mensaje-finalizada-text">
          <i class="icon f7-icons mensaje-finalizada-icon"
            >checkmark_circle_fill</i
          >
          Esta conversaciÃ³n ha sido finalizada
        </p>
      </div>
      <div class="messages"></div>
    </div>
  </div>
</template>

<style>
  .mensaje-finalizada-container {
    display: none;
    background: #f5f5f5;
    padding: 15px;
    text-align: center;
    border-bottom: 1px solid #ddd;
  }

  .mensaje-finalizada-text {
    margin: 0;
    color: #666;
    font-size: 14px;
  }

  .mensaje-finalizada-icon {
    color: #4caf50;
  }
</style>

<script>
  import io from "socket.io-client";
  import moment from "moment";
  import "moment/locale/es";
  import {
    getMensajesPorConversacion,
    enviarMensaje,
    finalizarConversacion,
    mensajeLeido,
    getConversaciones,
  } from "../js/services/index.js";

  export default (props, { $f7, $el, $on }) => {
    // --- Estado de la aplicaciÃ³n ---
    let messagebar,
      messages,
      socket = null;
    let mensajesData = [];
    let enviandoMensaje = false;
    let conversacionId,
      telefono = "Chat";
    let conversacionData = null;
    let conversacionFinalizada = false;

    // Configurar Moment.js
    moment.locale("es");

    // --- Utilidades ---
    const formatearFecha = (fecha) => {
      let dateString = fecha?.date || fecha;
      const momentDate = moment(dateString);

      if (!momentDate.isValid()) {
        console.error("Fecha invÃ¡lida:", fecha);
        return { hora: "--:--", completa: "Fecha invÃ¡lida" };
      }

      const ahora = moment();
      let hora;

      if (momentDate.isSame(ahora, "day")) {
        hora = momentDate.format("HH:mm");
      } else if (momentDate.isSame(moment().subtract(1, "day"), "day")) {
        hora = `Ayer ${momentDate.format("HH:mm")}`;
      } else if (momentDate.isSame(ahora, "week")) {
        const dia =
          momentDate.format("dddd").charAt(0).toUpperCase() +
          momentDate.format("dddd").slice(1);
        hora = `${dia} ${momentDate.format("HH:mm")}`;
      } else if (momentDate.isSame(ahora, "year")) {
        hora = `${momentDate.format("DD/MM")} ${momentDate.format("HH:mm")}`;
      } else {
        hora = `${momentDate.format("DD/MM/YY")} ${momentDate.format("HH:mm")}`;
      }

      return {
        hora: hora,
        completa: momentDate.format("DD/MM/YYYY HH:mm"),
        timestamp: momentDate.valueOf(),
      };
    };

    const crearFooterTiempo = (fecha) => {
      const tiempoFormateado = formatearFecha(fecha);
      return `<span style="font-size: 11px; color: #999; opacity: 0.7; font-weight: 400;">${tiempoFormateado.hora}</span>`;
    };

    const getEstadoIcono = (id_estado) => {
      const iconos = {
        1: ` <span style="font-size:12px;color:gray;">ðŸ•“</span>`,
        2: ` <span style="font-size:12px;color:gray;">âœ”</span>`,
        3: ` <span style="font-size:12px;color:rgba(139,69,19,0.6);">âœ”âœ”</span>`,
        4: ` <span style="font-size:12px;color:#2196f3;">âœ”âœ”</span>`,
      };
      return iconos[id_estado] || "";
    };

    const getElementosPorId = () => ({
      btnFinalizar: document.getElementById("btn-finalizar"),
      messagebarContainer: document.getElementById("messagebar-container"),
      mensajeFinalizada: document.getElementById("mensaje-finalizada"),
      messagesContent: document.getElementById("messages-content"),
    });

    // --- Reemplazar la funciÃ³n actualizarUISegunEstado con logs detallados ---
    const actualizarUISegunEstado = () => {
      console.log("ðŸ”§ INICIO actualizarUISegunEstado");
      console.log("ðŸ“Š conversacionFinalizada:", conversacionFinalizada);

      // âœ… Usar setTimeout para asegurar que el DOM estÃ© listo
      setTimeout(() => {
        console.log("â° Ejecutando timeout de actualizarUISegunEstado");

        const elementos = getElementosPorId();

        // ðŸ” Log detallado de cada elemento
        console.log("ðŸ” Elementos encontrados:");
        console.log("  - btnFinalizar:", elementos.btnFinalizar);
        console.log("  - messagebarContainer:", elementos.messagebarContainer);
        console.log("  - mensajeFinalizada:", elementos.mensajeFinalizada);
        console.log("  - messagesContent:", elementos.messagesContent);

        if (conversacionFinalizada) {
          console.log("ðŸ”’ APLICANDO estilos para conversaciÃ³n FINALIZADA");

          if (elementos.btnFinalizar) {
            elementos.btnFinalizar.style.setProperty("display", "none");
            console.log("  âœ… btnFinalizar oculto");
          } else {
            console.warn("  âš ï¸ btnFinalizar NO encontrado");
          }

          if (elementos.messagebarContainer) {
            elementos.messagebarContainer.style.setProperty("display", "none");
            console.log("  âœ… messagebarContainer OCULTO");
            console.log(
              "  ðŸ“ messagebarContainer display:",
              elementos.messagebarContainer.style.display
            );
          } else {
            console.warn("  âš ï¸ messagebarContainer NO encontrado");
          }

          if (elementos.mensajeFinalizada) {
            elementos.mensajeFinalizada.style.setProperty("display", "block");
            console.log("  âœ… mensajeFinalizada mostrado");
          } else {
            console.warn("  âš ï¸ mensajeFinalizada NO encontrado");
          }

          if (elementos.messagesContent) {
            elementos.messagesContent.style.setProperty("paddingBottom", "0px");
            console.log("  âœ… messagesContent padding ajustado");
          }

          console.log("ðŸ”’ ConversaciÃ³n finalizada - Controles deshabilitados");
        } else {
          console.log("âœ… APLICANDO estilos para conversaciÃ³n ACTIVA");

          if (elementos.btnFinalizar) {
            elementos.btnFinalizar.style.setProperty("display", "block");
            console.log("  âœ… btnFinalizar mostrado");
          } else {
            console.warn("  âš ï¸ btnFinalizar NO encontrado");
          }

          if (elementos.messagebarContainer) {
            elementos.messagebarContainer.style.setProperty("display", "block");
            console.log("  âœ… messagebarContainer MOSTRADO");
            console.log(
              "  ðŸ“ messagebarContainer display:",
              elementos.messagebarContainer.style.display
            );
          } else {
            console.warn("  âš ï¸ messagebarContainer NO encontrado");
          }

          if (elementos.mensajeFinalizada) {
            elementos.mensajeFinalizada.style.setProperty("display", "none");
            console.log("  âœ… mensajeFinalizada ocultado");
          } else {
            console.warn("  âš ï¸ mensajeFinalizada NO encontrado");
          }

          if (elementos.messagesContent) {
            elementos.messagesContent.style.setProperty(
              "paddingBottom",
              "44px"
            );
            console.log("  âœ… messagesContent padding ajustado");
          }

          console.log("âœ… ConversaciÃ³n activa - Controles habilitados");
        }

        // ðŸ” Verificar estado final del input
        const textarea = document.getElementById("message-input");
        console.log("ðŸ” Estado final del textarea:");
        console.log("  - textarea encontrado:", !!textarea);
        if (textarea) {
          console.log("  - textarea visible:", textarea.offsetParent !== null);
          console.log(
            "  - textarea display:",
            getComputedStyle(textarea).display
          );
          console.log(
            "  - textarea visibility:",
            getComputedStyle(textarea).visibility
          );
        }

        console.log("ðŸ”§ FIN actualizarUISegunEstado");
      }, 100);
    };

    const actualizarEstadoEnUI = (key, id_estado) => {
      const messageEls = $el.value[0].querySelectorAll(".message");
      const messageEl = messageEls[key];
      if (messageEl) {
        const textEl = messageEl.querySelector(".message-text");
        if (textEl) {
          const textoOriginal = textEl.innerText.replace(/âœ”.*/, "").trim();
          textEl.innerHTML = textoOriginal + getEstadoIcono(id_estado);
        }
      }
    };

    // --- Funciones principales ---
    const handleBackClick = (e) => {
      e.preventDefault();

      // Navegar especÃ­ficamente a la pÃ¡gina de chat principal
      $f7.views.main.router.navigate("/chat/principal", {
        force: true,
        ignoreCache: true,
      });
    };

    const handleFinalizarConversacion = () => {
      $f7.dialog.confirm(
        "Â¿EstÃ¡s seguro de que deseas finalizar esta conversaciÃ³n?",
        "Finalizar ConversaciÃ³n",
        async () => {
          try {
            $f7.preloader.show();
            const usuarioId = Number(localStorage.getItem("usuarioId"));
            const response = await finalizarConversacion(
              conversacionId,
              usuarioId
            );

            if (response.success) {
              $f7.toast
                .create({
                  text: "ConversaciÃ³n finalizada exitosamente",
                  closeTimeout: 2000,
                  position: "top",
                })
                .open();

              // 1. Actualizar la lista de conversaciones
              if (window.cargarDatos) {
                await window.cargarDatos();
              }

              // 2. Cerrar el socket
              if (socket) {
                socket.disconnect();
                socket = null;
              }

              // 3. OpciÃ³n A: Ir al dashboard (como un refresh)
              setTimeout(() => {
                $f7.views.main.router.navigate("/dashboard", {
                  force: true,
                  ignoreCache: true,
                  clearPreviousHistory: true,
                  reloadCurrent: true,
                });
              }, 500);

              // 4. OpciÃ³n B: Recargar la pÃ¡gina completamente
              // setTimeout(() => {
              //   window.location.reload();
              // }, 1000);
            } else {
              throw new Error(
                response.message || "Error al finalizar conversaciÃ³n"
              );
            }
          } catch (error) {
            console.error("Error al finalizar conversaciÃ³n:", error);
            $f7.dialog.alert(
              "No se pudo finalizar la conversaciÃ³n. Intenta nuevamente."
            );
          } finally {
            $f7.preloader.hide();
          }
        }
      );
    };

    const loadConversacionData = async () => {
      try {
        const conversaciones = await getConversaciones();
        conversacionData = conversaciones.find(
          (conv) => conv.conversacionId == conversacionId
        );

        if (conversacionData) {
          telefono = conversacionData.telefono || "Sin telÃ©fono";
          conversacionFinalizada = conversacionData.estadoId === 4;

          console.log(
            `ðŸ“Š Estado de conversaciÃ³n ${conversacionId}: ${conversacionData.estadoId} (Finalizada: ${conversacionFinalizada})`
          );

          // âœ… Actualizar tÃ­tulo de forma mÃ¡s segura
          setTimeout(() => {
            const navbarTitle = document.querySelector(".navbar .title");
            if (navbarTitle) {
              navbarTitle.textContent =
                telefono + (conversacionFinalizada ? " (Finalizada)" : "");
            }
          }, 50);

          // âœ… Actualizar UI despuÃ©s de cargar datos
          actualizarUISegunEstado();
        } else {
          console.warn(
            `âš ï¸ No se encontraron datos para conversaciÃ³n ${conversacionId}`
          );
        }
      } catch (error) {
        console.error("âŒ Error al cargar datos de conversaciÃ³n:", error);
      }
    };

    const handleHistorialFinalizada = () => {
      console.log(
        `ðŸ“œ Navegando al historial de conversaciÃ³n: ${conversacionId}`
      );
      $f7.views.main.router.navigate(
        `/historial-finalizado/${conversacionId}/`
      );
    };

    const renderMessages = () => {
      if (!messages || !mensajesData.length) return;
      messages.removeMessages();

      const mensajesOrdenados = [...mensajesData].sort(
        (a, b) => new Date(a.created_at || 0) - new Date(b.created_at || 0)
      );

      const messagesToAdd = mensajesOrdenados.map((msg) => {
        const esEnviado = msg.contesta !== "cliente";
        return {
          text: esEnviado
            ? msg.mensaje + getEstadoIcono(msg.id_estado)
            : msg.mensaje,
          type: esEnviado ? "sent" : "received",
          name: msg.contesta === "cliente" ? "Cliente" : "Yo",
          isHtml: esEnviado,
          footer: crearFooterTiempo(msg.created_at),
        };
      });

      messages.addMessages(messagesToAdd);
      console.log(
        `ðŸŽ¨ Renderizados ${messagesToAdd.length} mensajes con timestamps individuales`
      );
    };

    const loadMessages = async () => {
      try {
        mensajesData = (await getMensajesPorConversacion(conversacionId)) || [];
        console.log(`ðŸ“‹ Cargados ${mensajesData.length} mensajes`);
        renderMessages();

        if (!conversacionFinalizada) {
          // Mejorar el conteo de mensajes no leÃ­dos
          const mensajesNoLeidos = mensajesData.filter(
            (msg) =>
              msg.contesta === "cliente" &&
              (msg.id_estado === 1 ||
                msg.id_estado === 2 ||
                msg.id_estado === 3)
          );

          console.log(
            `ðŸ‘ï¸ Mensajes no leÃ­dos encontrados: ${mensajesNoLeidos.length}`
          );

          if (mensajesNoLeidos.length > 0) {
            // Marcar como leÃ­do solo los mensajes del cliente que no han sido leÃ­dos
            await Promise.all(
              mensajesNoLeidos.map(async (msg) => {
                try {
                  await mensajeLeido(msg.id);
                  console.log(`âœ… Mensaje ${msg.id} marcado como leÃ­do`);
                } catch (error) {
                  console.error(
                    `âŒ Error al marcar mensaje ${msg.id} como leÃ­do:`,
                    error
                  );
                }
              })
            );

            // Actualizar la lista de conversaciones para reflejar el cambio en el contador
            setTimeout(() => {
              if (window.cargarDatos) {
                window.cargarDatos();
                console.log(
                  "ðŸ”„ Lista de conversaciones actualizada despuÃ©s de marcar mensajes como leÃ­dos"
                );
              }
            }, 500);
          }
        }
      } catch (error) {
        console.error("âŒ Error al cargar mensajes:", error);
        $f7.dialog.alert("Error al cargar los mensajes");
      }
    };

    const sendMessage = async (messageText) => {
      if (!messageText?.trim()) return;

      enviandoMensaje = true;
      console.log("ðŸ“¤ Enviando:", messageText);

      const ahora = moment();
      const tiempoActual = ahora.toISOString();

      // Agregar mensaje inmediatamente a la UI
      messages.addMessage({
        text: messageText,
        type: "sent",
        name: "Yo",
        footer: crearFooterTiempo(tiempoActual),
      });

      // Agregar a los datos locales
      mensajesData.push({
        id: null,
        mensaje: messageText,
        contesta: "usuario",
        id_estado: 1,
        created_at: tiempoActual,
      });

      try {
        const payload = {
          id_conversacion: conversacionId,
          mensaje: messageText,
          contesta: "usuario",
          id_mensaje_whatsapp: null,
          id_mensaje_responde: null,
          id_estado: 1,
        };
        await enviarMensaje(payload);
        setTimeout(() => {
          enviandoMensaje = false;
        }, 2000);
      } catch (error) {
        $f7.dialog.alert("No se pudo enviar el mensaje");
        messages.removeMessage(messages.messages[messages.messages.length - 1]);
        mensajesData.pop();
        enviandoMensaje = false;
      }
    };

    const handleSendClick = () => {
      if (conversacionFinalizada) return;

      const textarea = document.getElementById("message-input");
      if (!textarea) return;

      const messageText = textarea.value.trim();
      if (!messageText) return;

      sendMessage(messageText);
      textarea.value = "";
      textarea.focus();
    };

    const handleKeyPress = (e) => {
      if (conversacionFinalizada) return;
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSendClick();
      }
    };

    // --- Socket ---
    const conectarSocket = () => {
      socket = io("http://82.180.163.151:3000/");

      socket.on("nuevo_mensaje", async (data) => {
        console.log("ðŸ“¨ Mensaje recibido:", data);

        if (data.id_conversacion != conversacionId) return;
        if (data.contesta === "usuario" && enviandoMensaje) return;

        if (["cliente", "bot"].includes(data.contesta)) {
          const nuevoMensaje = {
            mensaje: data.mensaje || data.texto,
            contesta: data.contesta,
            created_at: data.created_at || moment().toISOString(),
            id: data.id,
            id_estado: data.id_estado,
          };
          mensajesData.push(nuevoMensaje);

          const footerTiempo = crearFooterTiempo(nuevoMensaje.created_at);

          if (data.contesta === "cliente") {
            // Mejorar el avatar del cliente
            let iniciales = "C";
            if (conversacionData && conversacionData.telefono) {
              iniciales = conversacionData.telefono.substring(0, 2);
            }

            messages.addMessage({
              text: nuevoMensaje.mensaje,
              type: "received",
              name: conversacionData?.telefono || "Cliente",
              footer: footerTiempo,
            });
          } else if (data.contesta === "bot") {
            messages.addMessage({
              text: nuevoMensaje.mensaje + getEstadoIcono(data.id_estado),
              type: "sent",
              name: "Bot",
              isHtml: true,
              footer: footerTiempo,
            });
          }

          // Mejorar el manejo de mensajes no leÃ­dos
          if (
            data.contesta === "cliente" &&
            data.id &&
            !conversacionFinalizada
          ) {
            try {
              console.log(
                `ðŸ”µ Marcando mensaje ${data.id} como leÃ­do automÃ¡ticamente`
              );
              await mensajeLeido(data.id);

              // Actualizar inmediatamente el estado local
              const msgIndex = mensajesData.findIndex(
                (msg) => msg.id === data.id
              );
              if (msgIndex >= 0) {
                mensajesData[msgIndex].id_estado = 4; // Marcar como leÃ­do
              }

              // Actualizar la lista de conversaciones para actualizar el contador
              setTimeout(() => {
                if (window.cargarDatos) {
                  window.cargarDatos();
                  console.log("ðŸ”„ Contador de mensajes no leÃ­dos actualizado");
                }
              }, 200);
            } catch (error) {
              console.error("âŒ Error al marcar mensaje como leÃ­do:", error);
            }
          }

          if (data.contesta === "cliente") {
            $f7.toast
              .create({
                text: `Nuevo mensaje de ${
                  conversacionData?.telefono || "Cliente"
                }`,
                closeTimeout: 2000,
                position: "top",
              })
              .open();
          }
        }
      });

      socket.on("mensaje_actualizado", (data) => {
        console.log("ðŸ“¦ Estado actualizado:", data);
        let idx = mensajesData.findIndex((msg) => msg.id === data.id);

        if (idx >= 0) {
          mensajesData[idx].id_estado = data.id_estado;
          console.log(
            `ðŸ”„ Estado del mensaje ${data.id} actualizado a: ${data.id_estado}`
          );
        } else {
          idx = mensajesData.findIndex((msg) => msg.id === null);
          if (idx >= 0) {
            mensajesData.splice(idx, 1);
            mensajesData.push({
              id: data.id,
              mensaje: data.mensaje,
              contesta: data.contesta,
              created_at: data.created_at || moment().toISOString(),
              id_estado: data.id_estado,
            });
          }
        }

        if (idx >= 0) actualizarEstadoEnUI(idx, data.id_estado);

        // Si el mensaje fue leÃ­do, actualizar el contador en la lista de conversaciones
        if (data.id_estado === 4) {
          setTimeout(() => {
            if (window.cargarDatos) {
              window.cargarDatos();
              console.log(
                "ðŸ”„ Contador actualizado por cambio de estado a leÃ­do"
              );
            }
          }, 200);
        }
      });
    };

    // --- Ciclo de vida ---
    $on("pageInit", async (page) => {
      conversacionId =
        page.route?.params?.conversacionId ||
        $f7.views.main.router.currentRoute?.params?.conversacionId;

      if (!conversacionId) {
        $f7.dialog.alert("No se pudo obtener el ID de conversaciÃ³n");
        return;
      }

      console.log(`ðŸš€ Chat para conversaciÃ³n: ${conversacionId}`);

      // Ocultar el navbar principal
      const mainNavbar = document.querySelector(".view-main > .navbar");
      if (mainNavbar) {
        mainNavbar.style.display = "none";
      }

      messagebar = $f7.messagebar.create({ el: $el.value.find(".messagebar") });
      messages = $f7.messages.create({ el: $el.value.find(".messages") });

      setTimeout(() => {
        const textarea = document.getElementById("message-input");
        if (textarea) textarea.addEventListener("keypress", handleKeyPress);
      }, 100);

      await loadConversacionData();
      conectarSocket();
      setTimeout(loadMessages, 100);
    });

    $on("pageBeforeRemove", () => {
      enviandoMensaje = false;

      // Restaurar el navbar principal
      const mainNavbar = document.querySelector(".view-main > .navbar");
      if (mainNavbar) {
        mainNavbar.style.display = "block";
      }

      const textarea = document.getElementById("message-input");
      if (textarea) textarea.removeEventListener("keypress", handleKeyPress);
      if (messagebar) messagebar.destroy();
      if (messages) messages.destroy();
      if (socket) socket.disconnect();
      mensajesData = [];
    });

    return $render;
  };
</script>
