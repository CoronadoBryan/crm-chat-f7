<template>
  <div class="page">
    <!-- Navbar -->
    <div class="navbar">
      <div class="navbar-bg"></div>
      <div class="navbar-inner sliding">
        <div class="left">
          <a
            href="#"
            class="link"
            @click="${() => $f7.views.main.router.navigate('/')}"
          >
            <i class="icon icon-back"></i>
            <span class="if-not-md">Volver</span>
          </a>
        </div>
        <div class="title">${telefono}</div>

        <div class="right">
          <!-- Botón para finalizar conversación - Solo si NO está finalizada -->
          <button
            class="button button-fill color-red"
            @click="${handleFinalizarConversacion}"
            id="btn-finalizar"
            style="display: none"
          >
            Finalizar Conversación
          </button>

          <a class="link icon-only" @click="${handleHistorialFinalizada}">
            <i class="icon f7-icons">history</i>
            <i class="icon f7-icons">clock_fill</i>
          </a>

          <a href="#" class="link icon-only panel-open" data-panel="right">
            <i class="icon f7-icons if-not-md">menu</i>
            <i class="icon material-icons if-md">menu</i>
          </a>
        </div>
      </div>
    </div>

    <!-- Messagebar - Solo si NO está finalizada -->
    <div
      class="toolbar messagebar"
      id="messagebar-container"
      style="display: none"
    >
      <div class="toolbar-inner">
        <div class="messagebar-area">
          <textarea
            id="message-input"
            class="resizable"
            placeholder="Escribe un mensaje..."
          ></textarea>
        </div>
        <a class="link icon-only" @click="${handleSendClick}">
          <i class="icon f7-icons">arrow_up_circle_fill</i>
        </a>
      </div>
    </div>

    <!-- Mensajes -->
    <div class="page-content messages-content" id="messages-content">
      <!-- Mensaje de conversación finalizada -->
      <div
        id="mensaje-finalizada"
        style="
          display: none;
          background: #f5f5f5;
          padding: 15px;
          text-align: center;
          border-bottom: 1px solid #ddd;
        "
      >
        <p style="margin: 0; color: #666; font-size: 14px">
          <i class="icon f7-icons" style="color: #4caf50"
            >checkmark_circle_fill</i
          >
          Esta conversación ha sido finalizada
        </p>
      </div>
      <div class="messages"></div>
    </div>
  </div>
</template>

<script>
  import io from "socket.io-client";
  import {
    getMensajesPorConversacion,
    enviarMensaje,
    finalizarConversacion,
    mensajeLeido,
    getConversaciones,
  } from "../js/services/index.js";

  export default (props, { $f7, $el, $on }) => {
    // --- Variables de estado ---
    let messagebar,
      messages,
      socket = null;
    let mensajesData = [];
    let enviandoMensaje = false;
    let conversacionId,
      telefono = "Chat";
    let conversacionData = null;
    let conversacionFinalizada = false; // Nueva variable para controlar el estado

    // --- Función para verificar y actualizar UI según estado ---
    const actualizarUISegunEstado = () => {
      const btnFinalizar = document.getElementById("btn-finalizar");
      const messagebarContainer = document.getElementById(
        "messagebar-container"
      );
      const mensajeFinalizada = document.getElementById("mensaje-finalizada");
      const messagesContent = document.getElementById("messages-content");

      if (conversacionFinalizada) {
        // Conversación finalizada: ocultar controles
        if (btnFinalizar) btnFinalizar.style.display = "none";
        if (messagebarContainer) messagebarContainer.style.display = "none";
        if (mensajeFinalizada) mensajeFinalizada.style.display = "block";

        // Ajustar el contenido de mensajes para que ocupe todo el espacio
        if (messagesContent) {
          messagesContent.style.paddingBottom = "0px";
        }

        console.log("🔒 Conversación finalizada - Controles deshabilitados");
      } else {
        // Conversación activa: mostrar controles
        if (btnFinalizar) btnFinalizar.style.display = "block";
        if (messagebarContainer) messagebarContainer.style.display = "block";
        if (mensajeFinalizada) mensajeFinalizada.style.display = "none";

        // Restaurar padding para el messagebar
        if (messagesContent) {
          messagesContent.style.paddingBottom = "44px"; // Altura del messagebar
        }

        console.log("✅ Conversación activa - Controles habilitados");
      }
    };

    // --- Utilidades de UI ---
    const getEstadoIcono = (id_estado) => {
      switch (id_estado) {
        case 1:
          return ` <span style="font-size:12px;color:gray;">🕓</span>`;
        case 2:
          return ` <span style="font-size:12px;color:gray;">✔</span>`;
        case 3:
          return ` <span style="font-size:12px;color:rgba(139,69,19,0.6);">✔✔</span>`;
        case 4:
          return ` <span style="font-size:12px;color:#2196f3;">✔✔</span>`;
        default:
          return "";
      }
    };

    const actualizarEstadoEnUI = (key, id_estado) => {
      const messageEls = $el.value[0].querySelectorAll(".message");
      const messageEl = messageEls[key];
      if (messageEl) {
        const textEl = messageEl.querySelector(".message-text");
        if (textEl) {
          const textoOriginal = textEl.innerText.replace(/✔.*/, "").trim();
          textEl.innerHTML = textoOriginal + getEstadoIcono(id_estado);
        }
      }
    };

    const handleFinalizarConversacion = () => {
            $f7.dialog.confirm(
        "¿Estás seguro de que deseas finalizar esta conversación?",
        "Finalizar Conversación",
        async () => {
          try {
            $f7.preloader.show();
            const usuarioId = Number(localStorage.getItem("usuarioId"));
            const response = await finalizarConversacion(
              conversacionId,
              usuarioId
            );

            if (response.success) {
              $f7.toast
                .create({
                  text: "Conversación finalizada exitosamente",
                  closeTimeout: 2000,
                  position: "top",
                })
                .open();

              setTimeout(() => {
                $f7.views.main.router.navigate("/", {
                  reloadAll: true,
                });
              }, 1000);
            } else {
              throw new Error(
                response.message || "Error al finalizar conversación"
              );
            }
          } catch (error) {
            $f7.dialog.alert(
              "No se pudo finalizar la conversación. Intenta nuevamente."
            );
          } finally {
            $f7.preloader.hide();
          }
        }
      );
    };

    const loadConversacionData = async () => {
      try {
        const conversaciones = await getConversaciones();
        conversacionData = conversaciones.find(
          (conv) => conv.conversacionId == conversacionId
        );
        if (conversacionData) {
          telefono = conversacionData.telefono || "Sin teléfono";

          // Verificar si la conversación está finalizada
          conversacionFinalizada = conversacionData.estadoId === 4;
          console.log(
            `📊 Estado de conversación ${conversacionId}: ${conversacionData.estadoId} (Finalizada: ${conversacionFinalizada})`
          );

          const navbarTitle = document.querySelector(".navbar .title");
          if (navbarTitle) {
            navbarTitle.textContent =
              telefono + (conversacionFinalizada ? " (Finalizada)" : "");
          }

          // Actualizar UI según el estado
          actualizarUISegunEstado();
        } else {
          console.warn(
            `⚠️ No se encontraron datos para conversación ${conversacionId}`
          );
          console.log(
            "🔍 IDs disponibles:",
            conversaciones.map((c) => c.conversacionId)
          );
        }
      } catch (error) {
        console.error("❌ Error al cargar datos de conversación:", error);
      }
    };

    const handleHistorialFinalizada = () => {
      console.log(
        `📜 Navegando al historial de conversación: ${conversacionId}`
      );

      $f7.views.main.router.navigate(
        `/historial-finalizado/${conversacionId}/`
      );
    };

    const renderMessages = () => {
      if (!messages || !mensajesData.length) return;
      messages.removeMessages();
      const mensajesOrdenados = [...mensajesData].sort(
        (a, b) => new Date(a.created_at || 0) - new Date(b.created_at || 0)
      );
      const messagesToAdd = mensajesOrdenados.map((msg) => ({
        text:
          msg.contesta === "cliente"
            ? msg.mensaje
            : msg.mensaje + getEstadoIcono(msg.id_estado),
        type: msg.contesta === "cliente" ? "received" : "sent",
        name: msg.contesta === "cliente" ? "Cliente" : "Yo",
        isHtml: msg.contesta !== "cliente",
      }));
      messages.addMessages(messagesToAdd);
      console.log(`🎨 Renderizados ${messagesToAdd.length} mensajes`);
    };

    // --- Carga de mensajes históricos ---
    const loadMessages = async () => {
      try {
        mensajesData = (await getMensajesPorConversacion(conversacionId)) || [];
        console.log(`📋 Cargados ${mensajesData.length} mensajes`);
        renderMessages();

        // Solo marcar como leídos si la conversación NO está finalizada
        if (!conversacionFinalizada) {
          const mensajesNoLeidos = mensajesData.filter(
            (msg) => msg.id_estado === 3
          );
          console.log(
            `Mensajes no leídos a marcar como leídos${conversacionId}:`,
            mensajesNoLeidos
          );
          if (mensajesNoLeidos.length > 0) {
            await Promise.all(
              mensajesNoLeidos.map((msg) => mensajeLeido(msg.id))
            );
            setTimeout(() => {
              if (window.cargarDatos) window.cargarDatos();
            }, 200);
          }
        }
      } catch (error) {
        console.error("❌ Error al cargar mensajes:", error);
        $f7.dialog.alert("Error al cargar los mensajes");
      }
    };

    const sendMessage = async (messageText) => {
      if (!messageText || !messageText.trim()) return;
      enviandoMensaje = true;
      console.log("📤 Enviando:", messageText);

      messages.addMessage({ text: messageText, type: "sent", name: "Yo" });
      mensajesData.push({
        id: null,
        mensaje: messageText,
        contesta: "usuario",
        created_at: new Date().toISOString(),
        id_estado: 1,
      });

      try {
        const payload = {
          id_conversacion: conversacionId,
          mensaje: messageText,
          contesta: "usuario",
          id_mensaje_whatsapp: null,
          id_mensaje_responde: null,
          id_estado: 1,
          created_at: new Date().toISOString(),
        };
        const response = await enviarMensaje(payload);
        setTimeout(() => {
          enviandoMensaje = false;
        }, 2000);
      } catch (error) {
        $f7.dialog.alert("No se pudo enviar el mensaje");
        messages.removeMessage(messages.messages[messages.messages.length - 1]);
        mensajesData.pop();
        enviandoMensaje = false;
      }
    };

    // --- Eventos de UI ---
    const handleSendClick = () => {
      if (conversacionFinalizada) return; // Bloquear si está finalizada

      const textarea = document.getElementById("message-input");
      if (!textarea) return;
      const messageText = textarea.value.trim();
      if (!messageText) return;
      sendMessage(messageText);
      textarea.value = "";
      textarea.focus();
    };

    const handleKeyPress = (e) => {
      if (conversacionFinalizada) return; // Bloquear si está finalizada

      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSendClick();
      }
    };

    // --- Socket: conexión y eventos ---
    const conectarSocket = () => {
      socket = io("http://82.180.163.151:3000/");

      socket.on("nuevo_mensaje", async (data) => {
        console.log("📨 Mensaje recibido:", data);

        if (data.id_conversacion != conversacionId) return;
        if (data.contesta === "usuario" && enviandoMensaje) return;

        if (["cliente", "bot"].includes(data.contesta)) {
          const nuevoMensaje = {
            mensaje: data.mensaje || data.texto,
            contesta: data.contesta,
            created_at: data.created_at || new Date().toISOString(),
            id: data.id,
            id_estado: data.id_estado,
          };
          mensajesData.push(nuevoMensaje);

          if (data.contesta === "cliente") {
            messages.addMessage({
              text: nuevoMensaje.mensaje,
              type: "received",
              name: "Cliente",
            });
          } else if (data.contesta === "bot") {
            messages.addMessage({
              text: nuevoMensaje.mensaje + getEstadoIcono(data.id_estado),
              type: "sent",
              name: "Bot",
              isHtml: true,
            });
          }

          // Solo marcar como leído si la conversación NO está finalizada
          if (
            data.contesta === "cliente" &&
            data.id &&
            !conversacionFinalizada
          ) {
            try {
              console.log(
                `🔵 Marcando mensaje ${data.id} como leído automáticamente`
              );
              await mensajeLeido(data.id);

              setTimeout(() => {
                if (window.cargarDatos) window.cargarDatos();
              }, 200);
            } catch (error) {
              console.error("❌ Error al marcar mensaje como leído:", error);
            }
          }

          if (data.contesta === "cliente") {
            $f7.toast
              .create({
                text: "Nuevo mensaje del cliente",
                closeTimeout: 2000,
                position: "top",
              })
              .open();
          }
        }
      });

      socket.on("mensaje_actualizado", (data) => {
        console.log("📦 Estado actualizado:", data);
        console.log("🔍 Mensajes actuales:", mensajesData);
        console.log("🔍 Mensaje actualizado:", data.id);

        let idx = mensajesData.findIndex((msg) => msg.id === data.id);

        console.log("🔍 Índice del mensaje actualizado:", idx);
        if (idx == 1) {
          mensajesData[idx].id_estado = data.id_estado;
        } else if (idx < 0) {
          console.warn("⚠️ No se encontró el mensaje para actualizar");

          idx = mensajesData.findIndex((msg) => msg.id === null);

          mensajesData.splice(idx, 1);

          mensajesData.push({
            id: data.id,
            mensaje: data.mensaje,
            contesta: data.contesta,
            created_at: data.created_at || new Date().toISOString(),
            id_estado: data.id_estado,
          });
        }
        actualizarEstadoEnUI(idx, data.id_estado);
      });
    };

    // --- Ciclo de vida de la página ---
    $on("pageInit", async (page) => {
      conversacionId =
        page.route?.params?.conversacionId ||
        $f7.views.main.router.currentRoute?.params?.conversacionId;
      if (!conversacionId) {
        $f7.dialog.alert("No se pudo obtener el ID de conversación");
        return;
      }
      console.log(`🚀 Chat para conversación: ${conversacionId}`);

      messagebar = $f7.messagebar.create({ el: $el.value.find(".messagebar") });
      messages = $f7.messages.create({ el: $el.value.find(".messages") });

      setTimeout(() => {
        const textarea = document.getElementById("message-input");
        if (textarea) textarea.addEventListener("keypress", handleKeyPress);
      }, 100);

      await loadConversacionData();
      conectarSocket();
      setTimeout(loadMessages, 100);
    });

    $on("pageBeforeRemove", () => {
      enviandoMensaje = false;
      const textarea = document.getElementById("message-input");
      if (textarea) textarea.removeEventListener("keypress", handleKeyPress);
      if (messagebar) messagebar.destroy();
      if (messages) messages.destroy();
      if (socket) socket.disconnect();
      mensajesData = [];
    });

    return $render;
  };
</script>
